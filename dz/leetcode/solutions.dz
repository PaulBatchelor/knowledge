ns leetcode/problems
ns +110_balanced_binary_tree/solutions

nn top_down_recursion

nn bottom_up_recursion

ns ../..

ns leetcode
nn problems/1_two_sum/solution
ln Solution: use a hashmap. If the number
ln exists in the hashmap, a pair is found.
ln Otherwise store h[target - n] = i.
co $ ..
ff What is the solution to 1: two sum?
fb Solution: use a hashmap. If the number
fb exists in the hashmap, a pair is found.
fb Otherwise store h[target - n] = i.

nn problems/167_two_sum_ii/solution
ln Solution: two-pointer. The list is sorted,
ln so add numbers and increase/decrease the
ln ends depending on if it reaches the target
ln or not.
ff What is the solution to 167: two sum ii?
fb Solution: two-pointer. The list is sorted,
fb so add numbers and increase/decrease the
fb ends depending on if it reaches the target
fb or not.
co $ ..

nn problems/15_3sum/solution
co $ ..
ln Solution: Break this into a TwoSum problem
ln using two-pointer. Sort the numbers.
ln The two sum will do a check
ln starting with idx + 1, and then have logic to
ln skip duplicate numbers to ensure combinations
ln are unique. The main loop can break
ln early if the number is greater than 0 because
ln no numbers following it will be able to sum to
ln zero.
ff What is the solution to 15: 3sum?
fb Solution: Break this into a TwoSum problem
fb using two-pointer. Sort the numbers.
fb The two sum will do a check
fb starting with idx + 1, and then have logic to
fb skip duplicate numbers to ensure combinations
fb are unique. The main loop can break
fb early if the number is greater than 0 because
fb no numbers following it will be able to sum to
fb zero.

nn problems/20_valid_parentheses/solution
co $ ..
ln Solution: use a stack. Push if open, otherwise
ln pop and check. Make sure the string length is
ln even first, and at the end make sure the stack
ln is empty.
ff How do you solve 20: valid parenthesis?
fb Solution: use a stack. Push if open, otherwise
fb pop and check. Make sure the string length is
fb even first, and at the end make sure the stack
fb is empty.

nn problems/21_merge_two_sorted_lists/solution
co $ ..
ln Solution: linked list problem. Create
ln a dummy, and initially the tail to
ln be the dummy. While either
ln list not-null, determine which to use next.
ln If both lists exist, choose the smallest.
ln Otherwise append to the only remaining list.
ff Describe a way to solve 21: Merge Two Sorted Lists
fb Solution: linked list problem. Create
fb a dummy, and initially the tail to
fb be the dummy. While either
fb list not-null, determine which to use next.
fb If both lists exist, choose the smallest.
fb Otherwise append to the only remaining list.

nn problems/121_best_time_to_sell_and_buy_stock/solution
ln Solution: Greedy heuristic. Keep track of the smallest
ln value so far, and find the maximum value between
ln the current value and the smallest so far.
ff Describe a solution to 121: best time to sell and buy stock
fb Solution: Greedy heuristic. Keep track of the smallest
fb value so far, and find the maximum value between
fb the current value and the smallest so far.
co $ ..

nn problems/125_valid_palindrome/solution
ln Solution: use two-pointer. In the loop, skip non-alpha
ln characters (apparently alphanumeric, had to use
ln !isalnum() instead of !isalpha). Return false if things
ln don't match
ff Describe a solution to  125: valid palindrome
fb Solution: use two-pointer. In the loop, skip non-alpha
fb characters (apparently alphanumeric, had to use
fb !isalnum() instead of !isalpha). Return false if things
fb don't match

nn problems/226_invert_binary_tree/solution
ln Solution: recursively swap left/right children.
ff What is a solution to 226: invert binary tree?
fb Use recursion. Recursively swap left/right children.
co $ ..

nn problems/242_valid_anagram/solution
co $ ..
ln Solution: this is a hashmap problem. For each word, build
ln a hashmap containing the frequency of each letter. Then,
ln compare the hashmaps. Can be concisely and efficiently
ln solved in Python using a Counter.
ff How to solve 242: valid anagram?
fb Solution: this is a hashmap problem. For each word, build
fb a hashmap containing the frequency of each letter. Then,
fb compare the hashmaps. Can be concisely and efficiently
fb solved in Python using a Counter.

nn problems/704_binary_search/solution
ln Solution: this is a divide-and-conquer. Do the
ln lo/hi bound check while lo is less than hi, and check
ln and see if the converged target matches the result
ln the bounds are 0 to N, not N - 1.
ln But mindful of the subtleties here.
ln The lower bound
ln can be negative, so check for that at the. The returned
ln value is lo - 1 if it is a target.
ff How do you solve 704: binary search?
fb Solution: this is a divide-and-conquer. Do the
fb lo/hi bound check while lo is less than hi, and check
fb and see if the converged target matches the result
fb the bounds are 0 to N, not N - 1.
fb But mindful of the subtleties here.
fb The lower bound
fb can be negative, so check for that at the. The returned
fb value is lo - 1 if it is a target.

nn problems/733_flood_fill/solution
ln Use a queue. Use a hashmap
ln or set to keep track of visited positions. Pop a position,
ln Iterate over 4 directions. Make sure to mark it as visited
ln even if it is not a match. Filled colors get put onto
ln the queue.
ff What's a way to solve 733: flood fill?
fb Use a queue. Use a hashmap
fb or set to keep track of visited positions. Pop a position,
fb Iterate over 4 directions. Make sure to mark it as visited
fb even if it is not a match. Filled colors get put onto
fb the queue.


nn problems/235_lowest_common_ancestor_BST/solution
ff What is the solution to 235: Lowest common ancestor
ff of a binary search tree?
fb Algorithm: 1. start traversing from root node. 2. If both
fb sides p and q are in right subtree, continue search
fb with right tree starting with step 1. 3. If both nodes
fb p and q are in left subtree, continue the search with
fb left subtree starting step 1. If both steps 2 and
fb 3 are not true, we have found the common node which
fb is common to p and q's subtree. Return this node
fb as the common subtree.
co $ ..

nn problems/110_balanced_binary_tree/solution
ff What is one way to solve 110: Balanced Binary Tree
fb Used top-down recursion. Recursively find the
fb height of the left/right nodes. If the heights
fb are LTE 1, and the left/right nodes themselves are
fb balanced (recursive call), then it is balanced

nn problems/141_linked_list_cycle/solution
ff What is a solution to 141: linked list cycle?
fb One could use a hashtable, but the ideal approach is
fb to use Floyd's algorithm for cycle detection. Set up
fb a slow pointer and a fast pointer. If they match,
fb there's a cycle (true). If fast or fast.next is None, there
fb is no cycle (false).
co $ ..


nn problems/232_implement_queue_using_stacks/solution
ff What is a solution to 232: implement queue using stacks?
fb You can use a stack in O(1) time for pop, peek, and
fb empty operations. For push, drain stack A to stack B,
fb append the value to stack B, then drain stack B back to A.
fb The draining process reverses the ordering.
co $ ..

nn problems/278_first_bad_version/solution
ff What is the solution to 278: first bad version?
fb Binary search. When bounds checking, make sure hi=mid,
fb and lo = mid + 1. mid = lo + ((hi - lo)//2). Return lo.

nn problems/383_ransom_note/solution
ff What is the solution to 383: ransom note?
fb Hashmap. Get a frequency map/Counter for the magazine
fb and the ransom note. Iterate through the keys in the
fb ransomnote counter. If there aren't enough of a particular
fb letter in magazine or it doesn't exist, it is false.
fb Return true after the loop.
co $ ..

nn problems/70_climbing_stairs/solution
co $ ..
ff What is the solution to 70: climbing stairs?
fb Use dynamic programming. Realize that for any
fb given last step, you can either come from
fb the previous step (1 step) or the one before
fb that one (2 steps away), with those possible
fb combos. So the recurrene relation is s[n] =
fb s[n - 1] + s[n - 2], which you can reduce to
fb have memory of 2. Make sure to factor in
fb base cases.

nn problems/409_longest_palindrome/solution
co $ ..
ff What is the solution to 409: longest palindrome?
fb The core data structure is a hashmap. Build up
fb a frequency map of all the letters. Add up all
fb the even ones, and all the odd ones (but subtract 1).
fb At the end of the loop, add one if an odd number
fb was found.
fb A more optimized solution can be done by building
fb up the hashmap counter and keeping a "odd_freq_count"
fb variable. When the current count for a letter is odd,
fb increase the counter, and decrease it when even.
fb If the counter is zero, the length of the string
fb is the answer. Otherwise, len(s) - counter + 1.

nn problems/206_reverse_linked_list/solution
co $ ..
ff What is the solution to 206: reverse a linked list?
fb High level structure: iterate through a linked list,
fb which keeps track of the previous node, and return
fb the latest previous node. Inside the loop,
fb the current node next pointer should be updated
fb to the previous node, and the old value becomes
fb the current node.

nn problems/169_majority_element/solution
ff What is the solution to 169: majority element?
fb You can solve this with a hashmap. Build up
fb a frequency map, and return the largest.


nn problems/67_add_binary/solution
ff What is the solution to 67: add binary?
fb Convert numbers to stack. Pop and add binary
fb bits with a carry flag. When overflow happens
fb update the result bit: 0 when overflow is 2
fb (1 + 1), 1 when 3 (1 + 1 + carry). When one
fb of the stacks is exhausted, append the remaining
fb bits while keeping track of carry flag. Append
fb an extra bit if the carry flag is still on.

nn problems/543_diameter_of_binary_tree/solution
ff What is a solution to 543: diameter of binary tree?
fb This can be solved recursively using DFS. Traversal
fb works by finding the max height of the left/right
fb trees, and then adding those values together. Keep
fb track of the maximum during the traversal and return
fb that value.
co $ ..

nn problems/876_middle_of_linked_list/solution
ff What is the solution to 876: middle of linked list?
fb Fast/slow pointer. slow moves at 1x, fast moves at 2x.
fb Run while slow, fast, and fast.next. Return slow.
co $ ..

nn problems/104_max_depth_binary_tree/solution
ff What is the solution to 104: max depth of binary tree?
fb DFS recursion. If root is none, return 0. Else,
fb recursively call max depth on left/right, get the max
fb value, add 1.
co $ ..

nn problems/217_contains_duplicate/solution
ff What is the solution to 217: contains duplicate?
fb Use a Hash Set data structure. If the length of the set
fb is less than the length of the original array, there
fb are duplicates.
co $ ..

nn problems/53_maximum_subarray/solution
ff What is the solution to 217: maximum subarray?
fb Kadane's algorithm.
fb 1. initialize 2 variables 2 integer variables currentSubarray
fb and maxSubarray, set them equal to first value in subarray
fb 2. iterate through the array starting with 2nd element.
fb Add elemen to currentSubarray. Choose the greater value
fb to update currentSubarray: currentSubarray, or the
fb current value.
fb 3. Update max value.


nn problems/57_insert_interval/solution
ff How do you solve 57: insert interval?
fb It helps to draw a picture. Initialize a merged interval
fb variable to the new interval. Iterate through intervals
fb in the list. Anything before the start of the start
fb of the merged interval can be merged normally. Insert
fb the merged interval when there's an interval whose start
fb time is after the merged end time. While there is still
fb a merged interval, the merged interval is the smallest
fb start time of the current/merged plus the largest end
fb time of the current/merged. Insert intervals
fb normally after the merged interval has been made.
fb Insert the merged interval if it hasn't been inserted at
fb the end of the loop.
