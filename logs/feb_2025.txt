@2025-02-10 New logs, early morning
I'm at the hub now. Trying to figure out a better
log structure that can work on the order of years.
Right now, I'm going to see what it's like grouping logs
by month.

@09:39 settling in.

@09:50 trying out ed with my logs
so far, it is a little clumsy

@09:55 1-bit png support #timelog:00:51:10
#! dz dagzet/dzb/tasks/initial_work
we have this already, just need to retrofit it for
the codebase.

@10:47 break

@11:28 uf2 support #timelog:00:28:24
#! dz $
adapt from mnolth code, create example

@12:03 checksum for buffer, use in testing #timelog:00:26:26
#! dz $

@12:25 checksum test for fonts
#! dz $

@13:52 time to load in initial dagzet data, starting with keytree #timelog:01:31:10
#! dz dagzet/dzb/tasks/initial_dz_data

@13:59 path lookup table 
#! dz $

@17:44 Employed

@18:47 more path lookup table work. #timelog:00:34:15
#! dz $

@19:26 wow that was too much debugging
#! dz $

@19:36 right, now to load in key data. #timelog:00:27:18
#! dz $

@20:08 finally, a file loader for keys #timelog:00:29:48
#! dz $

@20:24 oops, there are two number fields not one
#! dz $

@2025-02-11 Ridgewood, maybe hub

@10:25 get the size parameter into key tree #timelog:00:16:47
#! dz dagzet/dzb/tasks/initial_dz_data

@10:52 intial scaffolding for loading JSON object #timelog:00:23:24
#! dz dagzet/dzb/tasks/initial_dz_data

@10:53 bringing in cJSON
@! dz $

@10:58 working on a loader function
@! dz $
I mainly need to do this to extract the JSON, I just
don't remember the schema

@11:40 importing some older knowledge graphs

@15:33 more object loading work #timelog:00:38:12
@! dz $

@18:04 object loading continued: nodes #timelog:00:15:00
@! dz $

@2025-02-12
@11:56 more object loading #timelog:00:15:50
@! dz $

@12:01 expanding the test framework
@! dz $
It's starting to get to the point where the unit tests
I want are smaller than the API I want to expose. So,
I'm doing rust-style unit tests, where the tests live
in the same file as the code. This will be due for a
re-org at some point, but good enough for now.

@12:15 Lunch

@12:49 continued #timelog:00:50:23
@! dz $

@12:51 nevermind not expanding test
$! dz $
I forgot about the asset data I'm baking. Do not want
to include that. I don't want to do macro magic today.

@13:16 enough of the node has been made, make a node list for subgraph
#! dz $

@13:40 we got nodes
#! dz $

@2025-02-13 Teaventure day
Most of my day was spent out in the city, assembling a very
fancy tea kit.

@20:17 initial planning for rendering architecture #timelog:00:56:49
#! dz dagzet/dzb/tasks/architecture_planning
I've been spending my days on the train today trying
to piece this together the problem I have. I want to build
a rendering pipeline suitable enough for UIs. This is of
course a not a new problem, with known solutions in the
web world. I want enough to be able to build tree structures
genenerated from the graph whose visibility can be
dynamically controlled.

@20:46 whoa, I really don't know how to do this
#! dz dagzet/dzb/tasks/architecture_planning
#! dz dagzet/dzb/refs/tree_view
All day, I've been thinking about a render model that
takes a tree of nested regions with offsets and widths
relative to the parent, somewhat similar to nested div
elements. Call it a render tree. This render tree
was going to be converted to a list of drawing operations.
---
I've been thinking about it wrong. I was imagining a
situation where you'd have a region of a fixed size, and
then you'd subdivide proportionally and fit everything
into that region. That... doesn't really work for presenting
an interactive "tree view".

@21:03 tempted to take the more low level tile-based approach first
#! dz dagzet/dzb/tasks/architecture_planning
#! dz dagzet/dzb/refs/tree_view
I'm trying to shove a DOM-based approach to producing flexible
render regions, but for a tree view using a fixed-width
bitmap font, a more tile-based approach could probably
work out better for rapid prototyping.

@21:10 high level short-term goals
#! dz dagzet/dzb/tasks/architecture_planning
#! dz dagzet/dzb/refs/tree_view
I've overcomplicated things because I wanted a high level
language for articulated UI similar to HTML. None of that.
---
basic needs: a tree view, a, card table, and logs
---
Tree view: for display an active tree: with interactions
like folding/unfolding, and clicking on a link to load
a new subtree.
---
Card table: a table with two columns: attribute and value.
---
Logs: list logs associated with a particular node. Print
timestamp, title and log. Be able to scroll.
