ns leetcode/problems
ns +110_balanced_binary_tree/solutions

nn top_down_recursion

nn bottom_up_recursion

ns ../..

ns leetcode
nn problems/1_two_sum/solution
ln Solution: use a hashmap. If the number
ln exists in the hashmap, a pair is found.
ln Otherwise store h[target - n] = i.
co $ ..
ff What is the solution to 1: two sum?
fb Solution: use a hashmap. If the number
fb exists in the hashmap, a pair is found.
fb Otherwise store h[target - n] = i.

nn problems/167_two_sum_ii/solution
ln Solution: two-pointer. The list is sorted,
ln so add numbers and increase/decrease the
ln ends depending on if it reaches the target
ln or not.
ff What is the solution to 167: two sum ii?
fb Solution: two-pointer. The list is sorted,
fb so add numbers and increase/decrease the
fb ends depending on if it reaches the target
fb or not.
co $ ..

nn problems/15_3sum/solution
co $ ..
ln Solution: Break this into a TwoSum problem
ln using two-pointer. Sort the numbers.
ln The two sum will do a check
ln starting with idx + 1, and then have logic to
ln skip duplicate numbers to ensure combinations
ln are unique. The main loop can break
ln early if the number is greater than 0 because
ln no numbers following it will be able to sum to
ln zero.
ff What is the solution to 15: 3sum?
fb Solution: Break this into a TwoSum problem
fb using two-pointer. Sort the numbers.
fb The two sum will do a check
fb starting with idx + 1, and then have logic to
fb skip duplicate numbers to ensure combinations
fb are unique. The main loop can break
fb early if the number is greater than 0 because
fb no numbers following it will be able to sum to
fb zero.

nn problems/20_valid_parentheses/solution
co $ ..
ln Solution: use a stack. Push if open, otherwise
ln pop and check. Make sure the string length is
ln even first, and at the end make sure the stack
ln is empty.
ff How do you solve 20: valid parenthesis?
fb Solution: use a stack. Push if open, otherwise
fb pop and check. Make sure the string length is
fb even first, and at the end make sure the stack
fb is empty.

nn problems/21_merge_two_sorted_lists/solution
co $ ..
ln Solution: linked list problem. Create
ln a dummy, and initially the tail to
ln be the dummy. While either
ln list not-null, determine which to use next.
ln If both lists exist, choose the smallest.
ln Otherwise append to the only remaining list.
ff Describe a way to solve 21: Merge Two Sorted Lists
fb Solution: linked list problem. Create
fb a dummy, and initially the tail to
fb be the dummy. While either
fb list not-null, determine which to use next.
fb If both lists exist, choose the smallest.
fb Otherwise append to the only remaining list.

nn problems/121_best_time_to_sell_and_buy_stock/solution
ln Solution: Greedy heuristic. Keep track of the smallest
ln value so far, and find the maximum value between
ln the current value and the smallest so far.
ff Describe a solution to 121: best time to sell and buy stock
fb Solution: Greedy heuristic. Keep track of the smallest
fb value so far, and find the maximum value between
fb the current value and the smallest so far.
co $ ..

nn problems/125_valid_palindrome/solution
ln Solution: use two-pointer. In the loop, skip non-alpha
ln characters (apparently alphanumeric, had to use
ln !isalnum() instead of !isalpha). Return false if things
ln don't match
ff Describe a solution to  125: valid palindrome
fb Solution: use two-pointer. In the loop, skip non-alpha
fb characters (apparently alphanumeric, had to use
fb !isalnum() instead of !isalpha). Return false if things
fb don't match

nn problems/226_invert_binary_tree/solution
ln Solution: recursively swap left/right children.
ff What is a solution to 226: invert binary tree?
fb Use recursion. Recursively swap left/right children.
co $ ..

nn problems/242_valid_anagram/solution
co $ ..
ln Solution: this is a hashmap problem. For each word, build
ln a hashmap containing the frequency of each letter. Then,
ln compare the hashmaps. Can be concisely and efficiently
ln solved in Python using a Counter.
ff How to solve 242: valid anagram?
fb Solution: this is a hashmap problem. For each word, build
fb a hashmap containing the frequency of each letter. Then,
fb compare the hashmaps. Can be concisely and efficiently
fb solved in Python using a Counter.

nn problems/704_binary_search/solution
ln Solution: this is a divide-and-conquer. Do the
ln lo/hi bound check while lo is less than hi, and check
ln and see if the converged target matches the result
ln the bounds are 0 to N, not N - 1.
ln But mindful of the subtleties here.
ln The lower bound
ln can be negative, so check for that at the. The returned
ln value is lo - 1 if it is a target.
ff How do you solve 704: binary search?
fb Solution: this is a divide-and-conquer. Do the
fb lo/hi bound check while lo is less than hi, and check
fb and see if the converged target matches the result
fb the bounds are 0 to N, not N - 1.
fb But mindful of the subtleties here.
fb The lower bound
fb can be negative, so check for that at the. The returned
fb value is lo - 1 if it is a target.

nn problems/733_flood_fill/solution
ln Use a queue. Use a hashmap
ln or set to keep track of visited positions. Pop a position,
ln Iterate over 4 directions. Make sure to mark it as visited
ln even if it is not a match. Filled colors get put onto
ln the queue.
ff What's a way to solve 733: flood fill?
fb Use a queue. Use a hashmap
fb or set to keep track of visited positions. Pop a position,
fb Iterate over 4 directions. Make sure to mark it as visited
fb even if it is not a match. Filled colors get put onto
fb the queue.
