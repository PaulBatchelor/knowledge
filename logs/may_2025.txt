@2025-05-03
@19:16 create more flashcards for HTTP status codes

@19:46 500 status codes now #timelog:00:10:45

@2025-05-08
@07:59 clone graph, continued #timelog:00:13:16
#! dz leetcode/problems/133_clone_graph
I did not finish this one
---
It looks like I forgot to copy over the values themselves,
which may be why I was getting the error.
---
I was appending the wrong thing to the queue. I should
have been the neighbor, not the newneighbor.

@08:15 polish notation #timelog:00:13:30
#! dz leetcode/problems/150_evaluate_polish_notation
I remember something weird was tripping me up with this
one. Might have been the thing that converts strings
to numbers? Or possibly the division?
---
This is basically a stack problem.
---
I got tripped up again. divide towards zero means
int(a/b), not a // b.

@2025-05-09
@07:59 course schedule #timelog:00:28:59
#! dz leetcode/problems/207_course_schedule
I remember this problem. It's a DAG problem.
---
This is sort of a traversal problem? You can take
all the prereqs, and put them in an adjacency list:
a lookup table for each node, and all their rerequisites.
---
after constructing the adjacency list, traverse BFS
using a queue. Begin by adding all the courses that do
not have prereqs onto the queue. Pop items off the queue,
and remove that course dependency from the adjacency list.
Add any courses that "free up".
---
I'm realizing I could construct my adjacency list a
little bit differently. Originally, I wanted to have the
list show the node and their prereqs, but the issue
with that is that you'd need to do many updates every time
a node is removed. It would be easier to show for each
node, which courses are dependent on it.
---
With this new list, you'd need to work backwards. You'd add
all the courses that are not dependencies for any other courses,
which would be the last courses.... wait this isn't going
to work.
---
Okay, back to the original plan I think. Maybe maintain
two lists?
---
or just have a counter that keeps track of the number of
---
we are out of time. I can't visualize the traversal correctly.

@08:43 revisiting #timelog:00:04:09
#! dz $
I was being do fancy, just pop dependency from set, do
a full sweep
---
oh shoot, this is the one where you can add phantom
edges isn't it.
---
Got it! Will clean up code and type up solution later

@19:31 code cleanup, explanation

@2025-05-14
@07:58 Implement Trie #timelog:00:07:16
#! dz leetcode/problems/208_implement_trie
I forget, can the Trie be a recursive structure?
It's a node with a value, a terminal node flag, and
a set of children in a lookup table. I think that
can be done recursively.

@08:06 coin change (initial) #timelog:00:24:22
#! dz leetcode/problems/322_coin_change
it's too early for coin change
---
this is a dynamic programming problem, optimizing for
fewest number of coins that make up a particular amount.
---
We are always trying to reach a particular target amount
using a given set of coins. If the target amount is less
than the smallest coin, there is no possible combination.
---
When a coin does fit into the target amount, we subtract
that from the target amount, and run it again, adding
1 coin. It would look something like: nCoins(amt) = 1 + nCoins(amt - coin)
---
I have to go, but things that are tripping me up are:
how to notate the recurrance relation? and how to keep
track of the minimum? how to track the invalid (negative)
value?
