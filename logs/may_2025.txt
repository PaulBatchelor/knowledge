@2025-05-03
@19:16 create more flashcards for HTTP status codes

@19:46 500 status codes now #timelog:00:10:45

@2025-05-08
@07:59 clone graph, continued #timelog:00:13:16
#! dz leetcode/problems/133_clone_graph
I did not finish this one
---
It looks like I forgot to copy over the values themselves,
which may be why I was getting the error.
---
I was appending the wrong thing to the queue. I should
have been the neighbor, not the newneighbor.

@08:15 polish notation #timelog:00:13:30
#! dz leetcode/problems/150_evaluate_polish_notation
I remember something weird was tripping me up with this
one. Might have been the thing that converts strings
to numbers? Or possibly the division?
---
This is basically a stack problem.
---
I got tripped up again. divide towards zero means
int(a/b), not a // b.

@2025-05-09
@07:59 course schedule #timelog:00:28:59
#! dz leetcode/problems/207_course_schedule
I remember this problem. It's a DAG problem.
---
This is sort of a traversal problem? You can take
all the prereqs, and put them in an adjacency list:
a lookup table for each node, and all their rerequisites.
---
after constructing the adjacency list, traverse BFS
using a queue. Begin by adding all the courses that do
not have prereqs onto the queue. Pop items off the queue,
and remove that course dependency from the adjacency list.
Add any courses that "free up".
---
I'm realizing I could construct my adjacency list a
little bit differently. Originally, I wanted to have the
list show the node and their prereqs, but the issue
with that is that you'd need to do many updates every time
a node is removed. It would be easier to show for each
node, which courses are dependent on it.
---
With this new list, you'd need to work backwards. You'd add
all the courses that are not dependencies for any other courses,
which would be the last courses.... wait this isn't going
to work.
---
Okay, back to the original plan I think. Maybe maintain
two lists?
---
or just have a counter that keeps track of the number of
---
we are out of time. I can't visualize the traversal correctly.

@08:43 revisiting #timelog:00:04:09
#! dz $
I was being do fancy, just pop dependency from set, do
a full sweep
---
oh shoot, this is the one where you can add phantom
edges isn't it.
---
Got it! Will clean up code and type up solution later

@19:31 code cleanup, explanation

@2025-05-14
@07:58 Implement Trie #timelog:00:07:16
#! dz leetcode/problems/208_implement_trie
I forget, can the Trie be a recursive structure?
It's a node with a value, a terminal node flag, and
a set of children in a lookup table. I think that
can be done recursively.

@08:06 coin change (initial) #timelog:00:24:22
#! dz leetcode/problems/322_coin_change
it's too early for coin change
---
this is a dynamic programming problem, optimizing for
fewest number of coins that make up a particular amount.
---
We are always trying to reach a particular target amount
using a given set of coins. If the target amount is less
than the smallest coin, there is no possible combination.
---
When a coin does fit into the target amount, we subtract
that from the target amount, and run it again, adding
1 coin. It would look something like: nCoins(amt) = 1 + nCoins(amt - coin)
---
I have to go, but things that are tripping me up are:
how to notate the recurrance relation? and how to keep
track of the minimum? how to track the invalid (negative)
value?

@2025-05-15
@07:37 more coin change attempts #timelog:00:38:42
#! dz leetcode/problems/322_coin_change
Working this out on pen and paper. Going to figure
out the recurrance relation. If I can grok that, I feel like
I'll know this problem cold.
---
I'm looking at the answer now.
---
Revisit coin change. Still struggling with setting up
the problem and seeing the patterns.

@08:17 Product of array except self #timelog:00:25:07
#! dz leetcode/problems/238_product_of_array_except_self
I vaguely recall needing to work this out on paper.
I think it involves keeping track of two prefix sum arrays?
One from left to right, the other from right to left.
---
The hint mentions an upper bound of 32 bits, so that
could be a hint.
---
Got it, the answer involved me carefully populating
a "left" product sum array with a "right" product sum
array. Writing an initial solution.

@2025-05-16

@08:06 min stack #timelog:00:04:51
#! dz leetcode/problems/155_min_stack
I think I remember looking this one up before. I think
it involves 2 stacks, one for the min value, one for
the items on the stack.

@08:14 validate binary search tree #timelog:00:23:56
#! dz leetcode/problems/98_validate_binary_search_tree
Looks like recursive DFS.
---
I've hit an edge case.
---
Right, the issue is that for a root node "5", it has
a right child of 6, with a left child of 3. 3 is in the
wrong place. There needs to be a minimum boundary and a maximum
boundary.
---
Looking at the answer.
---
oh jeez, inorder traversal. I forgot that inorder traversal
yields nodes in order. Basically, you keep track of the
previous value. You recursively go to the leftmost node,
then go back.
