@2025-11-01 Day 62
@07:29 pre-coffee puttering, hack on buddy system #timelog:00:10:50
#! dz %buddy_system

@11:29 more buddy system #timelog:01:10:12
#! dz $
I think alloc() works now? Two mistakes made: had to be
more explicit with what LOC(AVAIL[j]) was doing. I was
using virtual pointers for everything, which made things
interesting. There was also (x<-y<-z) notation used,
which I thought would be intermediate assignments like
"x = y, y = z", but I think it meant "set x = y = z".

@15:46 onto block "liberation" #timelog:01:31:35
#! dz $
For the record, the last bug was found by claude. It was
so subtle, only 1 line, I transcribed it wrong,
and knowing me it probably saved me about an hour of debugging
and careful checking.

@17:23 what's next for this #timelog:00:06:52
#! dz $
I gotta adapt the algorithm to work with a 64-sized block.
And, I gotta remove the gotos.
---
I've learned a few things writing this out. I've got things
set up in a way the algorithm is broken down into core operations
that I can re-implement without too much trouble. Then,
I can re-use the rest of the bits.
---
I need a way to bootstrap the initial block, and permanently
allocate a region of size 1 for the avail list, and a region
of size 2 for the tags. Those should predictably appear
in the first 3 words of the block. The temporary memory storying
locations for the avail list and the tags can then be copied
over to those memory locations, and the block can be used
as-is for the remainder of the lifetime.
---
The avail list has quirky behavior. when m = 6 it's a bool,
otherwise, it's an actual location. This logic needs to be
abstracted away cleanly.

@18:26 email from the prof: it's the "helo wrd" way #timelog:00:14:40
#! dz csmet/cs342/hw7
That makes it pretty easy.
---
Annnd we're done. Most of the time was spent just fighting
Java the language (generics, str.equals instead of ==), but
the algorithm was very simple.

@20:57 buddy system initial refactoring #timelog:01:28:45
#! dz %buddy_system
I need to get this ready for my block system approach.
---
Some initial refactoring is done. I'm trying to pull out
the tag and AVAIL list logic. I'm now at the point where
I'm getting the AVAIL list reworked so it can be external.
I think I've run into a small problem: I've assumed that
the AVAIL list can fit into 32 bits, and I don't think
that's true. I think each entry needs to be at least 12
bits, not 6 bits because it needs LINKF/LINKB addresses.
Also, I think I need 7 slots, not 6. So that's 84 bits,
which can fit onto 3 words. So that's 5 words total instead
of 3. So that's 58 words available, ~90% capacity self-contained.
---
I am hoping we don't need kval for this, otherwise that's
another word required. Each entry becomes 15 bits of information,
and that's 105 bits.
---
Alternatively, the state could be managed on another temp
block, which can be returned after the memory is set. Ideally,
I'll have enough flexibility to support both.

@2025-11-02 Day 63
@09:06 Logging in, some agenda cleanup and tweaks

@09:27 double check and then submit hw assignment #timelog:00:08:19
#! dz csmet/cs342/hw7

@09:37 let's try to pass unit 3 of CY100 #timelog:00:33:54
#! dz csmet/cy100
I think the test is graded wrong. The question is "ECC is
more efficient and suitable for environments with limited resources
compared to RSA." I answered "true" because that's what the slides said,
and I got it wrong.
---
The next question I got wrong was: "DSA is used exclusively for ___, not encryption".
I put down "verification" and "authentication", and neither of
those answers were correct.

@10:11 follow-ups with professor #timelog:00:10:12
#! dz csmet/cy100
His slides are still quite wrong to the point where I need
clarification.
---
I guess I'm going to be a stick in the mud now, huh?

@10:56 shopping for courses, planning ahead #timelog:00:34:48
#! dz csmet/news
Spring is another part time course. Next year will be all
full time, and the bulk of the price. On the order of about
87 percent of the tuition will be in fall 2026 and spring
2027. So this means, if I needed to, I could get out fairly
unscathed and pivot, without too much harm done other than
my sacrifice of leaving new york city and a year of time.
---
I'm getting the sense that I'm going to have to fight a
little bit if I'm going to stay in good academic standing
with this program. I don't know if it's worth the trouble.
I'm thinking about alternative options. Gonna have to start
talking to people.

@13:43 initial exploration #timelog:00:39:19
#! dz %sonilo/tasks/ilo_interpreter
I think this is mainly about adapting the existing ilo
byte code interpreter and pali assembler as much as possible.
---
The VM code seems like it'll mostly do the trick. I'll
probably want to simplify it a bit. I do not need or want
disk I/O so the blocks file should be optional.
---
pali seems to be a system mostly designed to produce a singular
ilo.rom file. I'm wondering if I could adapt the TAL
assembler to work with ILO opcodes instead of Uxn.
---
hang on, my 1-line test program works with pali. I might
be able to work with this in the very short-term.
---
At some point, I'll need more of an API for reading ILO
streams.
---
Wrote a dumb little program to print a character and multiply
some numbers, with some jump logic. Good enough for now.

@15:25 COAD logging and tasks continued #timelog:00:45:58
#! dz coad/toc
Added it to the reading list. It might be too much, we'll
see.

@17:00 scanning, cropping, binning #archiving #timelog:00:28:40

@18:39 more of this buddy system #timelog:00:11:26
#! dz %buddy_system
I flipped around the ordering of LINKF,LINKB,and KVAL
so that LINKF and LINKB are in the lower bits. My hope is
that the AVAIL table only needs those two values, and
I can just re-use the linkf/linkb routines.

@20:15 back to it #timelog:01:49:33
#! dz $
It's a lot of work to cram this all in one block, especially
considering that there will be some kind of wasted space.
Having a temporary block for bookkeeping seems like the
best option.
---
6 words will be needed (rounded up to 8, who knows
this temp block could be broken off from another buddy system).
---
4 words are needed for the AVAIL list. the LINKF/LINKB entries
will be pointers for a 6-bit address space with an extra bit
to indicate addresses on the temporary block. Each entry is
14 bits, that's 2 bits a word with padding, 4 words to get
7 entries.
---
tags will need 64 bits, so that's the remaining 2 words.
---
I've created availf/b v2 functions. They seem to work in
isolation, but when I put them in the program, it causes
an infinite loop to happen when the checksums. I'm guessing
it's some kind of addressing issue. I'll have to give it a look
another time.

@2025-11-03 Day 64. Happy birthday to me.

@10:18 make unit 4 pdf #timelog:00:15:00
#! dz csmet/cy100
@14:14 attempting to settle in

@18:00 cs342 #timelog:02:45:00

@2025-11-04 Day 65
@15:10 CY100 4.1: error detecting and message digest

@17:03 1.3 Rules of logic #timelog:00:47:54
#! dz dmoi/toc/01_logic_and_proofs/03_rules_of_logic

@2025-11-05 Day 66
@09:49 Update logs #timelog:00:01:31

@09:50 more buddy system #timelog:00:45:51
#! dz thoughts/projects/sonilo/tasks/buddy_system
Last time, I got some initial availf/availb v2 logic coded up,
which allows the avail list to be external. However,
when I coded it up, the program got caught in a loop.
I think it was where the traversal logic happened.
---
The checksums are wrong as well, so I'm overlooking something.
---
I'm writing a test program for AVAILF/AVAILB to see if
there are differents in output.
---
It looks like AVAILF is not being set properly. It doesn't
seem to be being set at all. It is being initialized correctly.
It's only after allocating a block that the AVAILF fields
start to misalign.
---
To be continued...

@14:29 DMOI 1.3 rules of logic reading #timelog:00:45:57
#! dz dmoi/toc/01_logic_and_proofs/03_rules_of_logic

@16:30 DMOI 1.3 continued #timelog:00:19:02
#! dz dmoi/toc/01_logic_and_proofs/03_rules_of_logic

@16:55 AVAIL investigations continued #timelog:00:31:59
#! dz thoughts/projects/sonilo/tasks/buddy_system
In the first allocation AVAILF(k) is supposed to be set to
be 70, but it never seems to be set, staying at 0. The availf
never explicitly sets itself to be 70. So linkf is making
that call I think.
---
I'm starting to see the issues. This new system needs
to create an abstraction for converting virtual memory
addresses into actual memory addresses. This algorithm
currently assumes AVAIL is contiguously after the block
(0-63 are the block address, 64-70 are the AVAIL entries).
---
I'm thinking of going back to one word to one entry. Space
is not an issue anymore because it's only temporarily
allocated. Then, there needs to be some kind of virtual
to physical memory resolver. So, anything that is between
0-63 gets an address from the block, anything greater than
that gets an address from the temp block. I think if we
do that, it's going to get much simpler.

@20:30 COAD 1.4 #timelog:00:47:43
#! dz coad/toc/01_computer_abstractions_and_technology/04_under_the_covers

@2025-11-06 Day 67
@09:45 CY100 4.2 Hash Algorithms
#! dz csmet/cy100

@10:48 COAD 1.5 technologies for building processors and memory #timelog:00:18:46
#! dz coad/toc/01_computer_abstractions_and_technology/05_tech_for_building_processors_and_memory

@11:10 1.5 continued #timelog:00:26:38
#! dz $

@12:50 1.4 proofs #timelog:00:38:47
#! dz dmoi/toc/01_logic_and_proofs/04_proofs

@14:38 4.3 data integrity protection #timelog:00:22:50
#! dz csmet/cy100
@15:05 logging #timelog:00:08:50

@18:00 cs248 #bumet #timelog:02:45:00
This class was boring, not terrifying. So, an improvement.
At this point, I'm thinking about my other options.

@2025-11-07 Day 68
@11:44 cs342 hw scoping #timelog:00:10:00
#! dz csmet/cs342/hw8
I glanced at this once, I'm going to look at it again.
---
2 problems
---
problem 1: use BFS to see if there is a path from source
to target in a graph.
---
problem 2: check to see if there is a cycle in an undirected
graph using Depth-First Search algorithm
---
Okay, might need to think on these. I only know kahn's algorithm
for cycle detection, but there was another way in class that
I'll need to review. BFS path/source doesn't seem too bad.
I think it's mostly about bookkeeping and using the right
data structure (queue instead of stack).

@12:49 cs342 hw8 initial work. interrupted. #timelog:00:04:13
#! dz $
My water bottle opened in my bag. My leather taschenbegleiter
is damaged. Shoot. Hopefully the damage isn't permanent.
---
weirdly the papers got wet, but there was no water damage.

@13:10 hw8 problem 2 initial work #timelog:00:26:00
#! dz $

@2025-11-08 Day 69
@11:36 transfer cs342 slides to remarkable, also print code? #timelog:00:16:12
#! dz csmet/cs342/hw8
I just want to study this outside of my computer area.
---
Learned about "enscript"
===
enscript -p - Graph.java | ps2pdf - Graph.pdf
===

@13:39 fill in problems in lecture notes #timelog:00:34:12
#! dz csmet/cs248

@14:06 work out problem 2 on ink #timelog:00:34:12
#! dz csmet/cs342/hw8

@15:12 initial attempt implementing problem 2 #timelog:00:03:00
#! dz csmet/cs342/hw8
I think I got it? I think it was basically the same as the
directed graph, but just an extra check for the parent.
Copy pasted most of it.

@15:21 looking into problem 1 now #timelog:00:21:17
#! dz $
Seems to work. I'll double check this later.

@20:47 1.6 Performance #timelog:00:49:58
#! dz coad/toc/01_computer_abstractions_and_technology/06_performance

@21:43 yup, buddy system #timelog:00:33:12
#! dz thoughts/projects/sonilo/tasks/buddy_system
I got the v2 system to match! Now to see if it lines up
with the first test I made.
---
Yup, it works now.
---
What is going to happen next is, I need to refactor this
to use an external block of memory. If TAGS and AVAIL
are lumped together, that's 9 words in a 16 word block (rounded up).
If TAGS and AVAIL are two separate blocks, that's 2 words (TAGS, 2 words),
and 8 words (AVAIL, 7 words). So, I'm going to allocate
AVAIL and TAGS separately in my buddy system.
---
I should probably also simulate the memory of sonilo by
using 2 blocks (2*64 = 128 words) of pre-allocated memory.
---
progress is slow, but it is still progress.

@2025-11-09 Day 70
We are approaching the 10% mark of the 730 day plan.

@09:08 DMOI 1.4 #timelog:00:48:30
#! dz dmoi/toc/01_logic_and_proofs/04_proofs

@10:13 Logging #timelog:00:07:31

@10:21 quick words about konilo-sonilo communication #timelog:00:19:24
#!  thoughts/projects/sonilo/tasks/konilo_sonilo_communication
This has popped up in my agenda, but I am behind because
of the buddy memory allocator. To keep momentum going, I'm
going to write down what I'm thinking about today.
---
I'm not 100% sold on using Konilo. I am a bit more
committed to using Ilo.
---
Communication, sonilo or otherwise, is going to boil down
to being a serial communication format. In Konilo, this would
be done using IO commands.
---
My initial thinking with using Konilo was that since both
systems used Ilo, there could be some convenience there.
It also seemed like Konilo had a pretty good self-contained
ecosystem in place already as an editor. The interactive
aspect of a Forth also seems in line with the aspect of
composing music.
---
So, developing a serial command language is going to be
more important than hooking things up to Konilo. It would
make sense to focus on this more, than actually hooking
it up to Konilo. Actually, it's a prerequisite. By the time
things are ready to actual integrate with Konilo, the serial
command language should already be in place.
---
Working on this task should mostly be about working with
the ergonomics of the Konilo ecosystem and making it work
with Sonilo command language.
---
I am developing a new task now.
---
Well, I've made a new task, but I think I need code in functionality
to re-import tasks into a grouped schedule.

@10:47 scheduler adjustments: add a "delete".
Select a group. Mark all selected items as "DELETED", import
the schedule again. Save.
