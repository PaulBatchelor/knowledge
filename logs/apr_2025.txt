@2025-04-02

@20:41 Create partially automated rust docs extractor #timelog:00:45:00
Added in playground/go/htmlparse. Incomplete. I think
I have all the raw ingredients, what is left is to generate
properly formatted dagzet code.

@2025-04-05
@09:59 Rust Scraper/card generator work #timelog:00:45:32
It works. I still need to do a little bit
of manual formatting with a downloaded rust page, but
I think it will save me some time.
---
Manual work involves: curling the page to an HTML page,
running "tidy" to make it easier to edit, and then
extracting just the section to be converted to cards,
which are just a pile of div/li elements. Then, this file
can be passed into the program and the resulting DZ file
gets printed to stdout.

@10:51 try out the new tool #timelog:01:07:50
Okay, it broke. the HTML formatting is different on Pin
and process. Let's see how hard it is to get this working.
---
working now, getting some automation tools set up

@2025-04-07
We have to get back on interview prep.

@21:41 Leetcode flashcards #leetcode-flashcards #timelog:00:29:31
I'd like to revisit these bits of my knowledge graph,
and attempt to turn as much as I can into flashcards.

@2025-04-08

@20:52 Rust flashcards #timelog:00:15:34

@2025-04-09

@21:47 Rust flashcards #timelog:00:07:39

@2025-04-10

@20:32 HTTP status code flashcards? #timelog:00:58:52
Managed to get 100, 200, 300. 400 and 500 left.

@2025-04-15

@20:52 rust doc HTML parser troubleshooting #timelog:00:12:40
It's not parsing the description text sometimes.
---
The "process" page looks fixed

@21:06 Onto fixing my mistakes. #timelog:00:21:00
Now, when did I start automating this process...

@2024-04-17
@21:02 Gently dipping my toes into leetcode again

@21:02 TwoSum
#! dz leetcode/problems/1_two_sum
I am a little rusty...

@21:51 peeking at ThreeSum
#! dz leetcode/problems/15_3sum
I think I want to try and do all problems related to TwoSum,
really get that pattern in my fingers.

@2025-04-19

@16:27 attempting ThreeSum again
#! dz leetcode/problems/15_3sum
The problem hints that if you keep one of the values
constant, it turns into a TwoSum problem. So, what you
want is to take X, and then find two values Y and Z
that add up to -X.
---
We tried this a few days ago, and it didn't work

@16:53 studying two-sum ii, in order to grok 3sum
#! dz leetcode/problems/167_two_sum_ii
Okay done. The solution was mostly spoiled already for me,
but it involved using two-pointer

@17:55 Another stab at 3sum
#! dz leetcode/problems/15_3sum
I started reading the editorial, and I solved two sum ii
while I was doing this. I think it they want you to
sort the list, and then perform it as a two-sum ii problem.
When you find the a pair, the ordering is guaranteed.
---
Having problems with the uniqueness logic.
---
I think we can take advantage of the sorted list. We only
want numbers in ascending order, so make sure the low
value starts at the index after the one being checked.
---
edge case didn't work
---
Looked at the solution: the twosum problem actually
added all three values together, not just one to get
a target. It also had logic that skipped over duplicate
values. The main loop also broke out early if there
were any values greater than zero, it indicated that
no numbers following it could sum to zero.

@18:23 Valid Parentheses
#! dz leetcode/problems/20_valid_parentheses
I think I remember this one being a stack problem.
You push open ones, and then if a closed one appears,
it needs to match the last element on the stack.
---
Issues: got my variables wrong. Didn't check the string
length to make sure it was a multiple of 2.
---
Another edge case: the stack needs to be empty at the
end of the function.

@2025-04-20

@10:41 Looking at b
#! dz/APL/b_study
can't get it to compile. oh well
---
the guide provides an overview of each of the
files, and provides some explanation for
some of the terse variables.
---
c.h has some basic definitions for a "terser C language".
I'm tempted to see how portable this one is, could
be helpful for my ed coding adventures.

@21:48 merge two sorted lists
#! dz leetcode/problems/21_merge_two_sorted_lists
linked list problem.

@2025-04-21

@07:48 Best time to buy and sell stock #timelog:00:09:44
#! dz leetcode/problems/121_best_time_to_sell_and_buy_stock
this is a greedy algorithm right? Because you are choosing
a local maximum (current minimum + next maximum)

@08:01 valid palindrome #timelog:00:09:31
#! dz leetcode/problems/125_valid_palindrome
Fundamentally, this feels like a two-pointer problem.
Once you filter the non-alphabetic characters, and deal
with case sensitivity, it's a matter of checking to
see if two ends of a string are equal. Loop ends
when the lo/hi pointers converge.
---
I got tripped on "0P" edgecase. It's because it's too
small and I'm skipping.
---
Attempting to set an initial palindrome flag to be false,
set to be true at the end of the loop.
If it breaks out of the loop without reaching the
bottom of the check, it's false.
---
Doesn't work either.
---
Damn. I used isalpha() instead of isalnum(). That was
my mistake.

@2025-04-21
@20:03 Peaking at DDIA again #timelog:00:04:59
Where did we leave off?
---
We seemed to have left off somewhere around chapter 10

@20:59 More DDIA #timelog:00:25:00
Finally finished outlining the summaries
---
Chapter 12 doesn't really have a summary. I guess I'll
have to actually read that.

@21:41 Go through DDIA notes, try to make flashcards
@2025-04-22
@07:36 Invert binary tree #timelog:00:06:36
This is a binary tree problem, and I believe the solution
can be solved recursively. Not sure if you'd call it
breadth first or depth first, probably depth-first.
---
For every node, swap the children. Then recursively go in
and swap those children.

@07:46 242 valid anagram #timelog:00:03:35
#! dz leetcode/problems/242_valid_anagram
Oops saw my one-liner. This is a hashmap problem, which
can be efficiently solved using the Counter type in
Python.

@07:50 704 binary search #timelog:00:22:13
#! dz leetcode/problems/704_binary_search
This problem wants you to implement a divide-and-conquer
binary search algorithm. Let's see if I can remember
how to set this up.
---
I have messed it up, damn.
---
I forgot about adding one to the midpoint index. It solves
some of them, but not all of them.
---
Say, why don't we look at the edge case that's failing,
and see if that gives us hints. It's an array of size 1 with
the element.
Do we add an exception in our binary search? Hopefully,
there's a way to adjust the algorithm to naturally compensate.
---
I keep getting tripped up on the subtleness of binary search.
---
Okay, I forget how to do binary search. Looking at the
answer because I'm at the 15 minute mark.
---
tweaks: while loop is LT, not LTE, conditional check is
LTE, the lo/hi bounds start at 0 and N, not N - 1. Do
the loop check when you break out of the loop.
---
Lots and lots of little things.

@08:14 Flood fill (planned, but didn't finish) #timelog:00:08:16
#! dz leetcode/problems/733_flood_fill
It's traversal? Use a queue (or stack?) to traverse
directions. Use a set to keep track of where you've been
(coordinates can work in a set because tuples are hashable).
Get the color of the starting pixel, push
the starting pixel onto the queue. While the queue
has things, process.
---
Inside the process: check the 4 directions of the current
position. If the pixel hasn't been visited before and
is the color of the start pixel color, switch it to the
new color, mark it as visited in the set, and append it
to the queue.
---
Make sure the mark the start pixel as visited.
---
Queue I think needs to be used because it's BFS. I think
the order of processing matters? Flood fill should move
outwards.

@19:48 flood fill continued #timelog:00:14:58
#! dz $
Well, something is wrong with my implementation
---
return image was in the wrong place, now the base cases pass
---
It works!

@2025-04-23
@07:47 LCA #timelog:00:25:57
#! dz leetcode/problems/235_lowest_common_ancestor_BST
Binary tree problem. DFS.
---
"lowest" means closest to leaves.
---
What are the possibilities?
---
One is that one of the nodes is an ancestor of the other node,
then you return the node that is highest.
---
Otherwise, the nodes have a common ancestor.
---
I guess an approach would be: find the first node in
the tree, then search for the other node, backtracking
if needed.
---
15 minutes passed. Strugglig formulating an answer. I
don't think my thinking is right. Giving up early.
---
Oh, it's a binary *search* tree. Glossed over that bit.
---
Wrote up algorithm solution. Typing out python solution
now to get it in my fingers.

@08:18 balanced binary tree (partial) #timelog:00:03:27
#! dz leetcode/problems/110_balanced_binary_tree
Now *this* is a binary tree problem.
---
I might not have enough time to finish this.
---
Use DFS to find the max depth of each child node.
If they differ by more than one, then they are not
balanced.
---
Think it has to be done recursively. I get the feeling
that there could be situations where heights are
equal from up high, but not when you go in layer
by layer.
---
To be continued...
