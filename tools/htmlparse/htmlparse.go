package main

import (
	"fmt"
	"golang.org/x/net/html"
	"os"
	"strings"
)

func main() {
	if len(os.Args) < 4 {
		fmt.Println("Please provide an HTML file path, basename, and base URL")
		fmt.Println("Usage: go run parser.go <html-file> <base-name> <base-url>")
		os.Exit(1)
	}

	filePath := os.Args[1]
	//url := "https://doc.rust-lang.org/std/iter"
	//basename := "iter";
	basename := os.Args[2]
	url := os.Args[3]

	file, err := os.Open(filePath)
	if err != nil {
		fmt.Println("Error opening file:", err)
		os.Exit(1)
	}
	defer file.Close()

	doc, err := html.Parse(file)
	if err != nil {
		fmt.Println("Error parsing HTML:", err)
		os.Exit(1)
	}
	//items := extractItemNames(doc)
	items := extractItemNamesV2(doc)
	urls := extractItemUrlsV2(doc)
	descriptions := extractDescriptionsV2(doc)


	fmt.Println("zz AUTOGENERATED FILE. Probably don't modify by hand?");
	printNameSpace(&basename);
	printStructsHeader(&url);

	for i, item := range items {
		name := item
		desc := descriptions[i]
		page := urls[i]

		printCard(&name, &basename, &url, &page, &desc);

	}

	printStructsFooter();
}

// extractText extracts all text content from the HTML document
func extractText(n *html.Node) string {
	if n.Type == html.TextNode {
		return n.Data
	}

	var result string
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		result += extractText(c)
	}

	return result
}

func getItemName(n *html.Node) string {
	return n.FirstChild.Data
}

func extractItemNames(n *html.Node) []string {
	var items []string

	if n.Type == html.ElementNode && n.Data == "div" {
		for _, attr := range n.Attr {
			if attr.Key == "class" && attr.Val == "item-name" {
				var name = getItemName(n.FirstChild)
				items = append(items, name)
				break
			}
		}
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		items = append(items, extractItemNames(c)...)
	}

	return items
}

// for HTML files with dt/dd instead of divs
func extractItemNamesV2(n *html.Node) []string {
	var items []string

	if n.Type == html.ElementNode && n.Data == "dt" {
		var name = n.FirstChild.FirstChild.Data
		items = append(items, name)
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		items = append(items, extractItemNamesV2(c)...)
	}

	return items
}

func getItemUrl(n *html.Node) string {
	var url string
	for _, attr := range n.Attr {
		if attr.Key == "href" {
			url = attr.Val
		}
	}
	return url
}

func extractItemUrls(n *html.Node) []string {
	var urls []string

	// Check if the node is an anchor element with href
	if n.Type == html.ElementNode && n.Data == "div" {
		for _, attr := range n.Attr {
			if attr.Key == "class" && attr.Val == "item-name" {
				var name = getItemUrl(n.FirstChild)
				urls = append(urls, name)
				break
			}
		}
	}

	// Recursively extract links from child nodes
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		urls = append(urls, extractItemUrls(c)...)
	}

	return urls
}


// extract the href inside of a dt element
func extractItemUrlsV2(n *html.Node) []string {
	var urls []string

	// Check if the node is an anchor element with href
	if n.Type == html.ElementNode && n.Data == "dt" {
		var name = getItemUrl(n.FirstChild)
		urls = append(urls, name)
	}

	// Recursively extract links from child nodes
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		urls = append(urls, extractItemUrlsV2(c)...)
	}

	return urls
}

func getDescription(n *html.Node) string {
	var desc string

	desc = extractText(n)

	return strings.ReplaceAll(desc, "\n", " ")
}

func extractDescriptions(n *html.Node) []string {
	var descs []string

	// Check if the node is an anchor element with href
	if n.Type == html.ElementNode && n.Data == "div" {
		for _, attr := range n.Attr {
			if attr.Key == "class" && attr.Val == "desc docblock-short" {
				var d = getDescription(n)
				descs = append(descs, d)
				break
			}
		}
	}

	// Recursively extract links from child nodes
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		descs = append(descs, extractDescriptions(c)...)
	}

	return descs
}

// find dd
func extractDescriptionsV2(n *html.Node) []string {
	var descs []string

	// Check if the node is an anchor element with href
	if n.Type == html.ElementNode && n.Data == "dd" {
		var d = getDescription(n);
		d = strings.ReplaceAll(d, "\n", " ");
		descs = append(descs, d)
	}

	// Recursively extract links from child nodes
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		descs = append(descs, extractDescriptionsV2(c)...)
	}

	return descs
}

func printNameSpace(base_name *string) {
	fmt.Printf("ns rust/std/modules/%s\n\n", *base_name);
}

func printStructsHeader(base_url *string) {
	fmt.Printf("nn structs\n");
	fmt.Printf("hl %s#structs\n", *base_url);
	fmt.Printf("co $ ..\n\n");
	fmt.Printf("ns +structs\n\n");
}

func printStructsFooter() {
	fmt.Printf("zz -structs\n");
	fmt.Printf("ns ..\n");
}

func printCard(name *string,
    base_name *string,
	base_url *string,
	page *string,
	desc *string) {

	fmt.Printf("nn %s\n", *name);
	fmt.Printf("hl %s/%s\n", *base_url, *page);
	fmt.Printf("co $ ..\n");
	/* TODO: word wrap? */
	fmt.Printf("ln %s\n", *desc);
	fmt.Printf("ff %s::%s\n", *base_name, *name);
	/* TODO: word wrap? */
	fmt.Printf("fb %s\n", *desc);
	fmt.Printf("\n");
}
